太棒了 ✅
以下是第六份進階文件 —— 這是讓整個系統自動化與可審計的核心部分。

---

# 《CI/CD Pipeline 深入設計手冊》

*(Continuous Integration & Continuous Deployment for Modular AI System)*

---

## 一、導論：從組裝到治理的自動化

當你的系統擁有 Core / Layer / Project 分層後，
下一步的挑戰是：

> **如何讓每一次提交、組裝、測試與發佈都能自動完成且可追溯。**

CI/CD Pipeline（持續整合 / 持續部署）
就是整個「模組化 AI 方法論」的**中樞神經系統**。

它的任務不只是 build，而是：

* **驗證資料結構一致性**
* **確保 GEM / Recipe / Code 相容性**
* **自動生成組裝成品與 Lockfile**
* **回傳測試與回歸結果報告**
* **自動發佈版本與 changelog**

---

## 二、整體流程圖

```mermaid
graph TD
    A[開發者提交 PR] --> B[CI: Schema & Code 檢查]
    B --> C[Build Prompt & Code]
    C --> D[Run Tests (Unit + Integration)]
    D --> E[Generate Artifacts & Lockfile]
    E --> F[Publish to Registry]
    F --> G[Generate Reports & Docs]
    G --> H[Deploy or Merge to Main]
```

---

## 三、Pipeline 任務拆解

| 階段   | 任務    | 主要工具                               | 輸出                        |
| ---- | ----- | ---------------------------------- | ------------------------- |
| CI-1 | 結構驗證  | `validate_recipe.py`, JSON Schema  | ✅ 結構通過報告                  |
| CI-2 | 組裝編譯  | `build_code.py`, `build_prompt.py` | ✅ 編譯成品                    |
| CI-3 | 單元測試  | `pytest`                           | ✅ 測試報告                    |
| CI-4 | 整合測試  | `integration_test.py`              | ✅ 整合狀態                    |
| CI-5 | 回歸比較  | `prompt_diff.py`                   | ✅ 回歸差異報告                  |
| CI-6 | 版本控制  | `publish_gem.py --auto`            | ✅ Registry 新版本            |
| CI-7 | 文檔與報告 | `generate_docs.py`                 | ✅ Build Report, Changelog |

---

## 四、GitHub Actions 工作流設定

`.github/workflows/ci_pipeline.yml`

```yaml
name: Modular AI CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest rich

      - name: Validate JSON Schemas
        run: python dev/layers/tools/validate_recipe.py --strict

      - name: Build All Prompts
        run: python core/prompts/tools/build_all_prompts.py

      - name: Build Layer Code
        run: python dev/layers/tools/build_code.py --all

      - name: Run Unit Tests
        run: pytest core/ dev/layers/ --maxfail=1 --disable-warnings -q

      - name: Run Integration Tests
        run: pytest dev/projects/ --maxfail=1 --disable-warnings -q

      - name: Compare Prompt Outputs (Regression Test)
        run: python core/prompts/tools/prompt_diff.py --auto

      - name: Generate Lockfile
        run: python dev/layers/tools/sync_registry.py

      - name: Publish GEM Registry (Main Branch)
        if: github.ref == 'refs/heads/main'
        run: python core/prompts/tools/publish_gem.py --auto

      - name: Generate Build Manifest & Docs
        run: python dev/layers/tools/generate_docs.py
```

---

## 五、Pipeline 關鍵模組設計

### 🧩 1️⃣ `validate_recipe.py`

**功能：** 驗證所有 Recipe 的欄位結構、版本、SSOT 一致性。

```python
import json, sys, glob

def validate_recipe(path):
    with open(path, 'r', encoding='utf-8') as f:
        data = json.load(f)
    assert "use_gems" in data, f"❌ {path}: Missing use_gems field"
    for g in data["use_gems"]:
        assert "name" in g and "version" in g, f"❌ {path}: Invalid GEM format"
    print(f"✅ {path} valid.")

if __name__ == "__main__":
    for file in glob.glob("dev/projects/**/prompts/recipes/*.json", recursive=True):
        validate_recipe(file)
```

---

### 🛠 2️⃣ `build_all_prompts.py`

**功能：** 遍歷所有專案 Recipe，自動組裝 Prompt。

```python
import os, glob

for recipe in glob.glob("dev/projects/**/prompts/recipes/*.json", recursive=True):
    os.system(f"python core/prompts/tools/build_prompt.py --recipe {recipe}")
```

---

### 🔒 3️⃣ `sync_registry.py`

**功能：** 驗證 Registry 與 Lockfile 的一致性，並更新版本鎖。

```python
import json, glob

def sync_lockfiles():
    registry = json.load(open("core/prompts/registry/index.json"))
    for lf in glob.glob("dev/projects/**/prompts/lockfile.json", recursive=True):
        lock = json.load(open(lf))
        for gem, version in lock["gems"].items():
            if gem not in registry or version not in registry[gem]:
                print(f"⚠️ {lf}: {gem}@{version} missing in registry")
        print(f"✅ {lf}: OK")

if __name__ == "__main__":
    sync_lockfiles()
```

---

### 🧪 4️⃣ `prompt_diff.py --auto`

**功能：** 比較前後兩次組裝 Prompt 的差異，確認語意一致性。

```bash
python core/prompts/tools/prompt_diff.py --auto
```

輸出範例：

```
🔍 Comparing previous vs current compiled prompts...
✅ No critical semantic differences detected.
```

---

### 🧾 5️⃣ `generate_docs.py`

**功能：** 自動產生報告與版本追蹤。

輸出：

```
docs/reports/build_manifest.json
docs/reports/test_results.json
docs/changelog/YYYY-MM-DD.md
```

---

## 六、回歸測試（Prompt Regression Testing）

這部分是 AI 系統中最重要的品質保證機制。

### 🔍 回歸測試定義

> 比較新版本 Prompt 與舊版本輸出的語意差異，
> 若超過允許閾值則阻止合併。

### 設計概念

| 項目   | 說明                                   |
| ---- | ------------------------------------ |
| 輸入集  | 固定測試輸入樣本集                            |
| 預期輸出 | 上一版本輸出的參考結果                          |
| 評分規則 | 使用語意相似度（LLM-based 或 embedding-based） |
| 容忍閾值 | 如 `cosine > 0.85` 視為一致               |

### 範例測試指令

```bash
python dev/layers/tools/prompt_regression_test.py \
  --project proj-first \
  --threshold 0.85
```

輸出：

```
✅ 98% of outputs within similarity threshold.
❌ 2 prompts failed semantic parity.
```

---

## 七、版本發佈策略

### 發佈命令

```bash
python core/prompts/tools/publish_gem.py \
  --name gem_simple_summary \
  --version 1.0.1 \
  --changelog "improved summary accuracy"
```

### 發佈流程

1️⃣ 驗證組裝與測試
2️⃣ 生成 SHA / version tag
3️⃣ 更新 `registry/`
4️⃣ 自動更新 `docs/changelog/`

---

## 八、Lockfile 機制

### 功能

* 確保專案永遠使用一致版本的 GEM
* 防止 Registry 更新導致意外破壞
* 提供可審計的依賴鏈

範例：

```json
{
  "project": "proj-first",
  "gems": {
    "gem_simple_summary": "1.0.1"
  },
  "compiled_at": "2025-11-06T13:00:00Z",
  "registry_sha": "a8c391e2"
}
```

---

## 九、報告輸出與可觀測性

### 📊 自動生成報告結構

```
docs/reports/
 ├─ build_manifest.json     # 組裝摘要
 ├─ test_results.json       # 測試結果
 ├─ regression_report.json  # 回歸測試
 └─ changelog/
      ├─ 2025-11-06.md
      └─ 2025-12-01.md
```

### 📘 `build_manifest.json` 範例

```json
{
  "build_id": "2025-11-06T13:00:00Z",
  "commit_hash": "b4c82f2",
  "projects_built": ["proj-first"],
  "total_prompts": 3,
  "total_tests_passed": 24,
  "registry_version": "v1.2.3"
}
```

---

## 十、Pipeline 監控建議

| 工具                          | 作用       | 配置                    |
| --------------------------- | -------- | --------------------- |
| **GitHub Actions Logs**     | 實時檢查流程   | 內建                    |
| **GitHub Pages**            | 展示報告     | 將 `/docs/reports/` 發佈 |
| **Slack / Discord Webhook** | 推播 CI 狀態 | `notifications.yml`   |
| **VS Code Tasks**           | 本地手動觸發   | `.vscode/tasks.json`  |
| **Prometheus + Grafana**    | 進階監控     | 可接入 Build Logs        |

---

## 十一、安全與審核

| 項目           | 機制                  |
| ------------ | ------------------- |
| 發佈 GEM 需審核   | `main` 分支受保護        |
| Registry 寫入  | 僅 CI/CD Token       |
| Prompt 改動    | PR 審核必須通過 Schema 驗證 |
| 測試覆蓋率        | 需達標才可合併             |
| Build Report | 自動產出，可供審核追蹤         |

---

## 十二、總結

| 關鍵指標      | 說明                           |
| --------- | ---------------------------- |
| **持續整合**  | 每次變更皆可被自動驗證                  |
| **持續部署**  | 通過測試後自動更新 Registry 與 Docs    |
| **回歸保障**  | 確保新版本不破壞舊邏輯                  |
| **審計可追溯** | 所有組件、版本、輸出皆可回查               |
| **透明治理**  | 所有操作均可在 VS Code / GitHub 可視化 |

---

> 💡 **一句話總結：**
> CI/CD 不只是「自動 build」，
> 它是讓模組化 AI 系統「**有生命、有免疫系統、有記憶**」的核心。

---

是否希望我接著幫你生成第七份（最後一份）
📙《治理與審查策略白皮書》（包含：版本演化治理模型、權限分層、審查流程、知識維護制度）？
