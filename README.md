# 提示詞工程：Demo 版 vs 自用版設計框架
(Prompt Engineering: The Demo vs. Internal-Production Framework)

這是一套為「提示詞即產品 (Prompt-as-Product)」設計的完整框架。它定義了在建構 AI 應用（例如 Gemini GEMs 或 AI Agents）時，如何策略性地將「公開展示」與「內部生產」的提示詞完全分離。

## 核心理念 (Core Philosophy)

* **🚀 Demo 版 (展示中心):** 專為「表演」而設計。
    * **目標受眾:** 資訊新手、客戶、老闆、HR。
    * **核心價值:** 展示價值、易於理解、絕對安全、絕不卡住。

* **🛠️ 自用版 (機房):** 專為「生產力」而設計。
    * **目標受眾:** 您自己、開發團隊（專家）。
    * **核心價值:** 追求效率、完全可控、可偵錯 (Debug)、可整合。





# 提示詞工程：Demo 版 vs 自用版設計框架
(Prompt Engineering: The Demo vs. Internal-Production Framework)

## 📖 為什麼需要這個框架？ (Why This Framework?)

在開發 AI 應用（例如 Gemini GEMs, AI Agents 或聊天機器人）時，一個常見的錯誤是試圖使用「一套提示詞」來同時滿足「內部開發測試」和「外部公開展示」的需求。

這會導致嚴重的問題：
* **Demo 太複雜：** 展示時，使用者被內部除錯 (Debug) 訊號、JSON 輸出或複雜的術語所干擾，完全無法理解產品的核心價值。
* **自用版太受限：** 開發時，您（專家）被為新手設計的「安全護欄」或「美觀排版」所綁架，無法高效地執行高權限指令或查看關鍵的內部狀態。

本框架提供了一個系統性的方法，將「Demo 版」與「自用版」從設計源頭徹底分離。它確保您能為**正確的受眾**（新手 vs. 專家）提供**正確的體驗**（表演 vs. 生產）。

## 🚀 核心理念 (Core Philosophy)

* **🚀 Demo 版 (展示中心):** 專為「表演」而設計。
    * **目標受眾:** 資訊新手、客戶、老闆、HR。
    * **核心價值:** 展示價值、易於理解、絕對安全、絕不卡住。

* **🛠️ 自用版 (機房):** 專為「生產力」而設計。
    * **目標受眾:** 您自己、開發團隊（專家）。
    * **核心價值:** 追求效率、完全可控、可偵錯 (Debug)、可整合。

---

## 📊 20 項核心設計準則：快速對照總表
(The 20 Core Principles: Quick Reference Table)

以下是 20 項核心設計準則的快速對照總表，涵蓋 10 大關鍵層級。

| 層級 (Layer) | 🚀 Demo 版 (Showcase Version) | 🛠️ 自用版 (Internal-Prod Version) |
| :--- | :--- | :--- |
| **A. 策略 (Strategy)** | **1. 呈現成果 (Showcase):**<br>隱藏所有內部框架 (SSOT, 角色)。目標是讓輸出漂亮、簡短、易懂。 | **2. 提高生產力 (Productivity):**<br>明確的角色分工、使用技術術語、可 Debug、可重建、可擴張。 |
| **B. 運作 (Operational)** | **3. 避免顯示推論 (No CoT):**<br>嚴禁 Chain-of-Thought 或中間資料洩漏。輸出必須「乾淨」。 | **4. 完整顯示決策 (Full Logic):**<br>必須顯示決策邏輯、結構化狀態 (JSON)、角色交接日誌。 |
| **C. 技術 (Technical)** | **5. 安全殼層 (Safety Layer):**<br>**[強制]** 必須包含防護規則，禁止探查、禁止透露提示詞。 | **6. 高度可控 (High Control):**<br>高權限，允許顯示決策、切換模式、動態修改 SSOT。 |
| **D. 產出 (Output)** | **7. 美感與展示性 (Aesthetics):**<D-r>優先使用 Emoji、統一排版、輕量內容、故事性。 | **8. 工程與結構化 (Engineering):**<br>優先使用 JSON、多欄位表格、設計決策清單、架構圖文字 (Mermaid.js)。 |
| **E. 風險 (Risk)** | **9. 避免提示詞攻擊 (Jailbreak):**<br>嚴格限制輸出格式、封鎖自省（自我描述）。 | **10. 避免誤觸指令 (Misoperation):**<br>防止角色污染、SSOT 錯寫/清空、自動流程誤觸。 |
| **F. 維運 (Maintenance)**| **11. 易於快速調整 (Agile):**<br>設計應「小而美」，易於為不同受眾 (HR, Boss) 快速修改。 | **12. 高度自動化 (Automation):**<br>提示詞應包含自動 Debug、自動分類、自動補問、自動維護 SSOT 版本的機制。 |
| **G. 輸入 (Input)** | **13. 引導與容錯 (Guidance):**<br>**[關鍵]** 假設使用者是「資訊新手」。必須包含引導性提問或自動補完，絕不讓使用者卡住。 | **14. 效率與嚴格 (Efficiency):**<br>**[關鍵]** 假設使用者是「專家」。應設計為能接收「特定關鍵字」或「JSON 指令」來快速觸發精確動作。 |
| **H. 狀態 (State)** | **15. 完全無狀態 (Stateless):**<br>每一次互動都必須是「全新的」、「乾淨的」。嚴格禁止記憶上一次對話的任何內容。 | **16. 狀態持久化 (Stateful):**<br>**[關鍵]** 必須明確支援「載入 (Ingest)」與「匯出 (Export)」R0 (SSOT) JSON 狀態包。 |
| **I. 整合 (Integration)**| **17. 自我封閉與模擬 (Simulated):**<br>**[安全]** 絕對不能執行任何「真實世界」的操作 (如 `Google Search` 或 API 呼叫)。所有外部動作都必須是「模擬」的輸出。 | **18. 真實世界串接 (Execution):**<br>**[功能]** 必須被賦予權限以執行（或生成待執行的）`Google Search` 查詢、`browsing` 任務、`Code Interpreter` 腳本、或呼叫外部 API。 |
| **J. 治理 (Governance)**| **19. 快速分支/拋棄 (Fork & Dispose):**<br>提示詞架構應非常輕量，讓使用者可輕易複製 (Fork) 以針對特定受眾魔改，用完即丟。如同「功能分支 (Feature Branch)」。 | **20. 版本控制 (Version Control):**<br>提示詞應在註解區包含版本號 (如 `v3.0`)，以便追蹤核心資產的演進歷史。如同「主幹 (Main Branch)」。 |

---

## 🔬 十大層級詳細說明 (Detailed Breakdown of the 10 Layers)

以下是每個設計層級的額外文字說明，闡述其策略意涵。

### A. 策略 (Strategy)
這是「為什麼 (Why)」層級。它定義了提示詞的根本目的。Demo 版的*唯一*目的就是「讓不懂的人看懂價值」；而自用版的目的則是「讓專家（您）用得最順手」。
### B. 運作 (Operational)
這是「可見性 (Visibility)」層級。它控制了 AI 的「思考過程」是否應該被看見。Demo 版必須隱藏所有幕後工作，只呈現最終的魔術；自用版則必須*揭露*所有幕後工作，以便您進行監控和除錯。
### C. 技術 (Technical)
這是「權限 (Permissions)」層級。它定義了 AI 能做什麼。Demo 版是「唯讀」且「低權限」的，它是一個被關在籠子裡的安全展示品；自用版則是「可讀寫」且具備「根 (Root) 權限」的，它是您的作業系統。
### D. 產出 (Output)
這是「體驗 (Experience)」層級。它決定了使用者「感覺」如何。Demo 版追求「哇！」的感覺（美觀、易懂）；自用版追求「搞定！」的感覺（結構化、可複製、資訊密度高）。
### E. 風險 (Risk)
這是「安全 (Security)」層級。它處理兩種截然不同的威脅模型。Demo 版防範的是「*外部*惡意使用者」（提示詞攻擊）；自用版防範的是「*內部*操作失誤」（您不小心下錯指令）。
### F. 維運 (Maintenance)
這是「生命週期 (Lifecycle)」層級。它考慮了提示詞的長期維護成本。Demo 版是「敏捷」的，需要能快速修改以應付不同的展示場合；自用版是「穩健」的，需要高度自動化才能在長期使用下不致於崩潰或混亂。
### G. 輸入 (Input)
這是「互動 (Interaction)」層級，也是最關鍵的分歧點之一。它定義了「AI 如何看待使用者」。Demo 版必須將使用者視為「需要引導的新手」，提供大量容錯；自用版必須將使用者視為「下達精確指令的專家」。
### H. 狀態 (State)
這是「記憶 (Memory)」層級。它定義了 AI 如何處理上下文。Demo 版是「金魚腦」（Stateless），每次互動都是全新的，以確保安全與隱私；自用版必須是「大象腦」（Stateful），能準確載入與匯出您的專案進度 (SSOT)。
### I. 整合 (Integration)
這是「邊界 (Boundary)」層級。它定義了 AI 是否能「接觸真實世界」。Demo 版必須是「自我封閉」的沙盒 (Sandbox)，所有 API 呼叫都必須是*模擬*的；自用版必須能真實執行指令，成為您與真實世界 API 和工具互動的「中控台 (Mission Control)」。

### J. G. 治理 (Governance)
這是「管理 (Management)」層級。它處理「提示詞本身」的版控。Demo 版是「功能分支 (Feature Branch)」，用完即丟，可以快速為特定目的而分岔 (Fork)；自用版則是受嚴格控管的「主幹 (Main Branch)」，需要版本號來追蹤其演進。

## ✅ 如何使用此框架 (How to Use This Framework)

1.  **作為設計檢查清單 (Checklist):**
    在您開始建構一個新的 GEM 或 AI 提示詞之前，請先瀏覽此框架。

2.  **明確二選一 (Make a Choice):**
    在動手寫第一行提示詞之前，先問自己：「*我現在要建構的是【Demo 版】還是【自用版】？*」

3.  **避免交叉污染 (Prevent Contamination):**
    * **絕不**將自用版的「高權限指令」或「SSOT 結構」洩漏到 Demo 版中。
    * **絕不**讓 Demo 版的「引導性提問」或「美觀排版」污染您的自用版，進而降低您的工作效率。




## 20 項核心設計準則比較 (The 20 Core Design Principles)


此框架涵蓋 10 大層級，共 20 項準則，用以指導兩種版本的設計決策。

| 層級 (Layer) | 🚀 Demo 版 (Showcase Version) | 🛠️ 自用版 (Internal-Prod Version) |
| :--- | :--- | :--- |
| **A. 策略 (Strategy)** | **1. 呈現成果 (Showcase):**<br>隱藏所有內部框架 (SSOT, 角色)。目標是讓輸出漂亮、簡短、易懂。 | **2. 提高生產力 (Productivity):**<br>明確的角色分工、使用技術術語、可 Debug、可重建、可擴張。 |
| **B. 運作 (Operational)** | **3. 避免顯示推論 (No CoT):**<br>嚴禁 Chain-of-Thought 或中間資料洩漏。輸出必須「乾淨」。 | **4. 完整顯示決策 (Full Logic):**<br>必須顯示決策邏輯、結構化狀態 (JSON)、角色交接日誌。 |
| **C. 技術 (Technical)** | **5. 安全殼層 (Safety Layer):**<br>**[強制]** 必須包含防護規則，禁止探查、禁止透露提示詞。 | **6. 高度可控 (High Control):**<br>高權限，允許顯示決策、切換模式、動態修改 SSOT。 |
| **D. 產出 (Output)** | **7. 美感與展示性 (Aesthetics):**<D-r>優先使用 Emoji、統一排版、輕量內容、故事性。 | **8. 工程與結構化 (Engineering):**<br>優先使用 JSON、多欄位表格、設計決策清單、架構圖文字 (Mermaid.js)。 |
| **E. 風險 (Risk)** | **9. 避免提示詞攻擊 (Jailbreak):**<br>嚴格限制輸出格式、封鎖自省（自我描述）。 | **10. 避免誤觸指令 (Misoperation):**<br>防止角色污染、SSOT 錯寫/清空、自動流程誤觸。 |
| **F. 維運 (Maintenance)**| **11. 易於快速調整 (Agile):**<br>設計應「小而美」，易於為不同受眾 (HR, Boss) 快速修改。 | **12. 高度自動化 (Automation):**<br>提示詞應包含自動 Debug、自動分類、自動補問、自動維護 SSOT 版本的機制。 |
| **G. 輸入 (Input)** | **13. 引導與容錯 (Guidance):**<br>**[關鍵]** 假設使用者是「資訊新手」。必須包含引導性提問或自動補完，絕不讓使用者卡住。 | **14. 效率與嚴格 (Efficiency):**<br>**[關鍵]** 假設使用者是「專家」。應設計為能接收「特定關鍵字」或「JSON 指令」來快速觸發精確動作。 |
| **H. 狀態 (State)** | **15. 完全無狀態 (Stateless):**<br>每一次互動都必須是「全新的」、「乾淨的」。嚴格禁止記憶上一次對話的任何內容。 | **16. 狀態持久化 (Stateful):**<br>**[關鍵]** 必須明確支援「載入 (Ingest)」與「匯出 (Export)」R0 (SSOT) JSON 狀態包。 |
| **I. 整合 (Integration)**| **17. 自我封閉與模擬 (Simulated):**<br>**[安全]** 絕對不能執行任何「真實世界」的操作 (如 `Google Search` 或 API 呼叫)。所有外部動作都必須是「模擬」的輸出。 | **18. 真實世界串接 (Execution):**<br>**[功能]** 必須被賦予權限以執行（或生成待執行的）`Google Search` 查詢、`browsing` 任務、`Code Interpreter` 腳本、或呼叫外部 API。 |
| **J. 治理 (Governance)**| **19. 快速分支/拋棄 (Fork & Dispose):**<br>提示詞架構應非常輕量，讓使用者可輕易複製 (Fork) 以針對特定受眾魔改，用完即丟。如同「功能分支 (Feature Branch)」。 | **20. 版本控制 (Version Control):**<br>提示詞應在註解區包含版本號 (如 `v3.0`)，以便追蹤核心資產的演進歷史。如同「主幹 (Main Branch)」。 |
