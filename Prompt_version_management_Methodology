# 🧩 提示詞方法論 (Prompt Engineering Methodology)

---

## 一、導論：從文字到邏輯

傳統的提示詞工程（Prompt Engineering）將每個提示詞視為一段靜態文字。這種做法雖然簡單，但難以維護、無法重用，也缺乏測試機制。

**模組化提示詞方法論**的核心思想是：

> 把提示詞視為「功能模組 (Functional Module)」，並以軟體工程的邏輯進行管理。

這樣的思維使提示詞開發具備程式碼般的特性：**版本化、模組化、可測試、可組裝**。

---

## 二、方法論核心：八項原則

### 📘 三、原則對應摘要表（方法論總覽）

| 原則編號 | 名稱             | 關鍵理念           | 實踐焦點       | 關聯角色  |
| ---- | -------------- | -------------- | ---------- | ----- |
| 1    | 提示詞即程式碼 (PaC)  | Prompt 有版本與測試性 | 使用 Git 管理  | 全員    |
| 2    | 模組化與單一職責 (SRP) | 一個元件只做一件事      | 拆分功能模組     | R1    |
| 3    | 關注點分離 (SoC)    | 資料、邏輯、組裝分開     | 建立明確資料夾架構  | 全員    |
| 4    | 組合優於繼承         | 功能積木式組裝        | JSON 宣告組合  | R2    |
| 5    | DRY 原則         | 功能不重複定義        | 單一元件重複引用   | R1    |
| 6    | 宣告式建構          | 宣告「要什麼」而非「怎麼做」 | 編輯 recipes | R2    |
| 7    | SSOT 介面        | 元件間不直接溝通       | 維護共享資料結構   | R0    |
| 8    | 可測試性           | 支援單元與整合測試      | 建立測試框架     | R1/R2 |

---

## 三、原則細節說明

### 原則一：提示詞即程式碼 (Prompts as Code - PaC)

**操作目標：**
讓所有提示詞具備「版本控制、可追溯、可測試」三要素。

**操作規範：**

1. 每個提示詞檔案須納入 Git 版本管理。
2. 重大修改需以 Commit message 記錄意圖。
3. 禁止以 Google Docs、Notion 作為正式版本來源。

---

### 原則二：模組化與單一職責 (Modularity & SRP)

**操作目標：**
確保每個提示詞元件專注於一項功能。

**操作規範：**

1. 每個模組命名以 `fn_` 開頭，例如 `fn_generate_summary.md`。
2. 模組需明確定義輸入與輸出欄位。
3. 不得在同一模組中同時執行分析與生成行為。

---

### 原則三：關注點分離 (Separation of Concerns - SoC)

**操作目標：**
使資料流、邏輯流與組裝流三者分離，避免交錯。

**操作規範：**

1. 目錄結構必須遵循以下模式：

```text
components/      → 功能元件（功能邏輯）
recipes/         → 組裝配方（宣告結構）
compiled_prompts/→ 自動生成的最終提示詞
tools/           → 組裝與測試工具
```

2. 不得將「配方宣告」內容硬寫進元件。
3. 不得在 `components/` 目錄中混放執行腳本。

---

### 原則四：組合優於繼承 (Composition over Inheritance)

**操作目標：**
以「組合」方式產生新提示詞，而非修改既有模板。

**操作規範：**

1. 使用 JSON 宣告組合：

```json
{
  "name": "spec_C",
  "components": ["fn_a", "fn_b", "fn_j"]
}
```

2. 禁止手動複製貼上既有提示詞內容。
3. 元件之間不得直接互相引用文字內容。

---

### 原則五：DRY 原則 (Don't Repeat Yourself)

**操作目標：**
避免重複定義邏輯，使功能只存在於一處。

**操作規範：**

1. 所有共用邏輯應封裝為獨立模組。
2. 若兩個模組功能重疊，需重構合併。
3. 重複段落應提取為共享元件。

---

### 原則六：宣告式建構 (Declarative Assembly)

**操作目標：**
讓開發者僅需宣告「要什麼」，而非手動組裝。

**操作規範：**

1. 所有組裝由自動工具（如 `build_prompt.py`）負責。
2. 禁止人工拼接模組內容。
3. `recipes/` 只允許使用宣告格式（JSON / YAML）。

---

### 原則七：SSOT 介面 (Single Source of Truth)

**操作目標：**
確保模組之間透過單一共享狀態進行溝通。

**操作規範：**

1. 所有資料交換須經 SSOT（共享資料結構）。
2. 元件僅能操作授權欄位。
3. SSOT 結構範例：

```json
{
  "project_spec": {
    "intent": "",
    "analysis": {},
    "summary": "",
    "report": ""
  }
}
```

---

### 原則八：可測試性 (Testability)

**操作目標：**
確保每個模組與最終組合可被驗證。

**操作規範：**

1. 每個模組需有對應單元測試。
2. 每個組合配方需有整合測試。
3. 若組裝出錯，需能明確指出失效模組。

---

## 四、三層架構導入：從功能單元到可用系統

在模組化方法論的基礎上，引入三層結構，使提示詞開發接近軟體工程的「函式 → 套件 → 應用」思維。

| 層級              | 名稱                 | 說明                | 類比軟體概念 |
| --------------- | ------------------ | ----------------- | ------ |
| 🧩 Module（功能模組） | 單一功能單元，如意圖分析、格式化輸出 | Function          |        |
| 💎 GEM（組合模組）    | 多個模組組裝成的功能組件，可共用   | Library / Package |        |
| 🚀 Prompt（應用層）  | DEMO 或自用版提示詞       | Application       |        |

**邏輯：**

> Module 定義「功能」，GEM 負責「整合」，Prompt 對應「實際應用」。

---

## 五、結語

透過八項原則與三層結構，提示詞開發從「巨石文字」轉化為「可管理的系統」。
這讓提示詞不僅是一段文字，而是一個**可維護的邏輯資產**。
