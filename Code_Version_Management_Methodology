# 💻 程式碼方法論 (Code Engineering Methodology)

---

## 一、導論：從指令到結構

傳統程式開發若缺乏架構思維，容易演變為「功能堆疊」的巨石式程式碼。這樣的系統難以維護、測試與擴充。

**模組化程式碼方法論**的核心思想是：

> 將程式視為邏輯模組的組合，使其具備結構清晰、可重用、可測試的工程特性。

---

## 二、方法論核心：八項原則

### 📘 三、原則對應摘要表（方法論總覽）

| 原則編號 | 名稱             | 關鍵理念             | 實踐焦點           | 關聯角色  |
| ---- | -------------- | ---------------- | -------------- | ----- |
| 1    | 程式即邏輯資產 (CaA)  | 程式具版本與測試性        | 使用 Git 管理      | 全員    |
| 2    | 模組化與單一職責 (SRP) | 一個模組只做一件事        | 拆分功能模組         | 開發者   |
| 3    | 關注點分離 (SoC)    | 資料、邏輯、展示分離       | 明確目錄架構         | 全員    |
| 4    | 組合優於繼承         | 函式與服務組合          | JSON / DI 管理依賴 | 架構師   |
| 5    | DRY 原則         | 功能不重複定義          | 建立共用模組         | 開發者   |
| 6    | 宣告式依賴管理        | 宣告「依賴關係」而非「手動整合」 | 使用配置或容器        | 架構師   |
| 7    | Context 介面     | 模組透過上下文溝通        | 維護共享狀態結構       | 系統工程師 |
| 8    | 可測試性           | 支援單元與整合測試        | 建立測試框架         | 全員    |

---

## 三、原則細節說明

### 原則一：程式即邏輯資產 (Code as Architecture - CaA)

**操作目標：**
讓所有程式模組具備版本管理、可測試、可追溯特性。

**操作規範：**

1. 程式碼需納入 Git 版本控制。
2. 重大變更需撰寫明確 Commit message。
3. 禁止以未版本化的臨時檔案作為正式版本。

---

### 原則二：模組化與單一職責 (Modularity & SRP)

**操作目標：**
每個函式或類別模組只負責一項明確功能。

**操作規範：**

1. 函式命名應清楚表達目的，如 `parse_json()`、`analyze_text()`。
2. 一個模組不得同時處理資料與展示邏輯。
3. 超過 200 行的模組需進行拆分。

---

### 原則三：關注點分離 (Separation of Concerns - SoC)

**操作目標：**
讓資料流、邏輯流與展示流彼此分離。

**操作規範：**

1. 目錄結構必須遵循以下格式：

```text
src/            → 程式核心邏輯
services/       → 商業邏輯或服務層
api/            → 輸入輸出介面層
config/         → 系統設定與宣告
scripts/        → 工具與自動化腳本
```

2. 禁止在同一檔案中同時處理資料與呈現邏輯。
3. 確保每層只負責其定義職責。

---

### 原則四：組合優於繼承 (Composition over Inheritance)

**操作目標：**
以組合的方式整合功能，而非建立複雜的繼承鏈。

**操作規範：**

1. 優先以「組合物件」實現多功能整合。
2. 避免多重繼承與深層父類關係。
3. 使用依賴注入 (DI) 或配置式宣告統一依賴管理。

---

### 原則五：DRY 原則 (Don't Repeat Yourself)

**操作目標：**
減少重複邏輯與代碼片段，確保功能集中管理。

**操作規範：**

1. 重複程式段應抽象為共用函式。
2. 共用邏輯統一放置於 `utils/` 或 `core/`。
3. 禁止複製貼上其他模組邏輯。

---

### 原則六：宣告式依賴管理 (Declarative Dependency Management)

**操作目標：**
讓依賴關係明確可追溯，而非隱性耦合。

**操作規範：**

1. 使用 `requirements.txt` 或 `package.json` 管理依賴。
2. 透過配置檔 (YAML / JSON) 宣告模組間依賴關係。
3. 禁止在程式中硬編碼外部依賴。

---

### 原則七：Context 介面 (Contextual Interfaces)

**操作目標：**
確保模組之間的溝通透過統一的 Context 物件。

**操作規範：**

1. 所有模組的資料交換須透過 Context 物件。
2. Context 結構需以 Schema 定義，例如：

```json
{
  "user": {"id": "", "role": ""},
  "session": {"input": "", "output": ""},
  "state": {"logs": []}
}
```

3. 模組僅能修改授權欄位。

---

### 原則八：可測試性 (Testability)

**操作目標：**
確保每個模組可被單元測試與整合測試覆蓋。

**操作規範：**

1. 每個功能需對應至少一個 `test_*.py` 測試檔案。
2. 單元測試聚焦於函式行為；整合測試模擬實際流程。
3. 若測試失敗，錯誤應指向具體模組。

---

## 四、三層架構導入：從函式到應用系統

在模組化方法論基礎上，建立對應於軟體工程的三層邏輯結構：

| 層級                  | 名稱           | 說明                | 類比概念 |
| ------------------- | ------------ | ----------------- | ---- |
| 🧩 Function（功能函式）   | 單一功能邏輯單元     | Function          |      |
| 💎 Module（功能模組）     | 整合多個函式的可重用單元 | Library / Package |      |
| 🚀 Application（應用層） | 組合多模組形成可執行系統 | Application       |      |

**邏輯：**

> Function 定義「功能」、Module 組合「邏輯」、Application 執行「系統」。

---

## 五、結語

透過八項原則與三層結構，程式開發不再是片段代碼的堆疊，而是一個有邏輯、有秩序、可維護的系統設計過程。

> **程式碼不只是指令，而是邏輯資產。**
> 每一段程式，都應是可重組、可驗證、可演化的邏輯單元。
